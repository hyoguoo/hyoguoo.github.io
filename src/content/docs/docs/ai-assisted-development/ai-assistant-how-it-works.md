---
title: "AI 어시스턴트의 작동 원리"
date: 2025-10-24
lastUpdated: 2025-12-20
---

과거의 도구는 정해진 규칙(linting 등)으로 코드를 검사했으나, 반면 현대의 AI 어시스턴트는 대형 언어 모델(LLM)을 기반으로 한다.

- 기능 구현: 자연어 명령을 실제 코드로 변환
- 디버깅: 버그 리포트를 분석하고, 문제의 원인을 찾아 수정 방안 제시
- 테스트 작성: 기존 코드를 분석하여 테스트 케이스 자동 생성
- 워크플로우 수행: 깃 메시지 작성, 코드 리뷰, 문서화 등 개발 수명 주기 전반

AI 어시스턴트는 단순 자동 완성 도구가 아닌, 개발자의 생산성을 획기적으로 향상시키는 강력한 도구이다.

## 컨텍스트(Context)

컨텍스트(Context)란 AI가 현재 작업을 수행하기 위해 알아야 하는 모든 '정보'를 의미한다.

1. 대화 내역: 이전 대화에서 주고받은 메시지
2. 참조된 코드/파일: 사용자가 명시적으로 지정한 소스 코드
3. 프로젝트 구조: AI가 파악한 프로젝트의 전체 폴더 및 파일 목록
4. 시스템 프롬프트: AI의 역할이나 규칙을 미리 지정해 둔 기본 설정값

### 컨텍스트 구성 방식

사용자가 입력하는 메시지만이 컨텍스트의 전부가 아닌, AI가 실제로 작업을 처리할 때 여러 요소가 조합되어 채워진다.

- 시스템 프롬프트
    - 컨텍스트 윈도우의 맨 처음에 위치
    - AI의 정체성, 역할, 기본 규칙을 정의
    - 사용자가 직접 수정하기 전까지 모든 대화에 기본적으로 적용
- 참조된 코드/파일
    - 사용자가 파일을 참조하거나, AI가 프로젝트 구조를 분석할 때 발생
    - AI는 전체 프로젝트를 통째로 컨텍스트에 넣는 것이 불가능하므로, 관련성 높은 코드 조각들만 선별하여 추가
- 대화 내역
    - 이전 대화들이 순서대로 컨텍스트에 포함
- 사용자 입력
    - 사용자가 마지막에 입력한 새로운 질문이나 명령이 컨텍스트의 맨 끝에 추가

이 모든 요소가 합쳐져 하나의 거대한 프롬프트(명령문)를 구성하고, AI 모델은 이를 바탕으로 응답을 생성한다.

## Context Window의 한계와 토큰

AI의 응답 품질이 갑자기 떨어지거나 의도를 파악 못한다면, 대부분 '컨텍스트 용량 초과' 문제 때문이다.

- 토큰(Token): AI가 정보를 처리하는 기본 단위
- Context Window: AI가 한 번에 기억할 수 있는 토큰의 최대 개수
- 한계: 이 용량을 넘어서는 정보(긴 대화, 많은 참조 파일)가 입력되면, AI는 가장 오래된 정보부터 잊어버리기 시작

따라서 AI 성능을 높이려면, 한정된 컨텍스트 윈도우 안에 지금 작업에 꼭 필요한 정보만 정확하게 넣어주는 관리(prompt engineering)가 필수적이다.

### 토큰(Token)의 작동 방식과 비용

토큰은 단순히 단어가 아닌, AI가 세상을 이해하는 어휘(Vocabulary) 집합에 가깝다.

- 토큰화(Tokenization)
    - 모델은 학습 데이터에서 통계적으로 자주 등장하는 문자열을 하나의 토큰으로 인식
    - 예를 들어 `function`이나 `import`처럼 자주 쓰이는 단어는 1개의 토큰으로 처리
    - 하지만 `MyCustomVariable` 같은 드문 단어는 `My`, `Custom`, `Variable`처럼 3개 이상의 토큰으로 분리될 수 있음
- 언어별 효율 차이
    - 대부분의 모델은 영어 데이터 위주로 학습
    - 따라서 영어는 1단어 = 1토큰에 가까워 효율이 높음
    - 한국어는 구조가 달라 한 글자나 조사가 별도 토큰으로 분리되는 경우가 많음(예: '안녕하세요' -> '안녕', '하세', '요' 3~4 토큰)
    - 동일한 의미의 질문도 한국어로 하면 영어보다 더 많은 토큰이 소모될 수 있음
- 비용과 직결되는 문제
    - 대부분의 AI 서비스는 사용한 토큰의 총량에 따라 비용을 청구
    - `입력 토큰 수(컨텍스트) + 출력 토큰 수(AI 응답)` = 총비용
    - 컨텍스트 윈도우가 크다는 것 -> 한 번에 더 많은 토큰을 처리할 수 있다는 의미
    - 거대한 파일을 통째로 첨부하거나, 불필요하게 긴 대화를 이어가는 것은 AI의 성능 저하뿐만 아니라 직접적인 비용 증가로 이어짐

## RAG

AI가 수백 개의 파일로 이루어진 프로젝트를 다루기 위해 RAG(Retrieval-Augmented Generation)라는 기술을 사용한다.

1. 색인화(Indexing)
    - 코드를 작은 조각(chunk)으로 나누고, 각 조각의 '의미'를 나타내는 수학적 좌표(Vector Embedding)를 계산하여 데이터베이스에 저장
    - 예: `UserService.java` 파일의 `login()` 메서드 코드를 하나의 조각으로 나누고, 해당 코드의 벡터를 생성하여 색인에 추가
2. 검색(Retrieval)
    - 사용자가 "로그인 관련 버그 수정해줘"라고 질문하면, AI는 이 질문의 의미(벡터)와 가장 가까운 코드 조각(벡터)을 색인에서 탐색
    - 이때 '로그인', '인증', 'User' 등의 키워드뿐만 아니라, 의미적으로 관련된 코드(e.g., `SecurityConfig`, `JwtProvider`)도 함께 탐색
3. 증강(Augmentation)
    - AI는 이렇게 찾아낸 3~5개의 가장 관련성 높은 코드 조각을 컨텍스트 창에 자동으로 삽입
    - 마지막으로 사용자 질문("...버그 수정해줘")과 함께 이 코드 조각들을 AI에 전달
4. 생성(Generation)
    - AI는 제공된 코드 조각과 질문을 바탕으로 응답을 생성

## 외부 도구 연동

초기 AI 어시스턴트는 단순히 텍스트 응답만 생성했지만, 현대 AI는 실제 도구를 직접 사용할 수 있다.

### Function Calling(Tool Use)

AI가 응답 생성 중 외부 도구가 필요하다고 판단하면, 도구를 호출하고 그 결과를 바탕으로 최종 답변을 생성한다.

1. 서울의 실시간 날씨 정보 요청
2. AI가 날씨 정보는 실시간 API가 필요하다고 판단
3. `get_weather(location="서울", date="오늘")` 형태로 도구 호출
4. API가 `{"temp": 15, "condition": "맑음"}` 응답 반환
5. AI가 해당 응답을 바탕으로 최종 응답 생성

### MCP 도구 연동의 표준화

AI가 외부 도구와 통신을 위해선 아래와 같은 한계점이 존재했다.

- 과거에는 각 도구마다 다른 연동 방식을 사용
- AI 어시스턴트마다 지원하는 도구가 제한적이었으며, 새 도구를 추가하기 위해 모델 재학습이나 커스텀 필요

하지만 MCP(Model Context Protocol) 도입 후에는 새 도구를 플러그인처럼 추가할 수 있으며, AI 모델 수정 없이도 기능을 확장할 수 있게 되었다.

### MCP 작동 구조

MCP는 세 가지 핵심 구성 요소로 이루어진다.

1. MCP 클라이언트(AI 어시스턴트)
    - 사용자 요청 분석
    - 필요한 도구(MCP 서버) 선택
    - 도구 실행 결과를 자연어로 변환
2. MCP 프로토콜(통신 규약)
    - 표준화된 메시지 형식(JSON-RPC 기반)
    - 요청/응답 구조 정의
    - 에러 처리 및 타임아웃 관리
3. MCP 서버(실제 도구)
    - 특정 작업 수행(파일 읽기, 브라우저 제어, API 호출 등)
    - MCP 프로토콜로 AI와 통신
    - 실행 결과를 표준 형식으로 반환

예를 들어 로그인 페이지 테스트와 같은 요청이 오면 다음과 같은 과정이 진행된다.

1. MCP 클라이언트가 요청을 분석해 적절한 MCP 서버(브라우저 자동화) 선택
2. MCP 프로토콜을 통해 Playwright 서버에 `{"method": "browser.navigate", "params": {"url": "..."}}` 메시지 전송
3. Playwright 서버가 실제 브라우저를 실행하고 테스트를 수행
4. MCP 프로토콜로 `{"status": "success", "screenshot": "...", "errors": [...]}` 결과 반환
5. AI가 이를 해석하고 자연어로 변환하여 사용자에게 전달한다.

### 주요 MCP 서버 유형

- 파일시스템: 파일 읽기/쓰기, 디렉토리 탐색
- 브라우저 자동화: 웹페이지 테스트, 스크린샷, UI 검증
- 데이터베이스: SQL 쿼리 실행, 스키마 분석
- API 통합: 외부 서비스 호출 (Slack, GitHub, Notion 등)
- 코드 분석: 심볼 검색, 의존성 추적, 리팩토링 지원
- 검색 엔진: 웹 검색, 문서 조회, 실시간 정보 수집

### 한계와 주의사항

- 컨텍스트 윈도우 압박
    - 도구 호출 결과도 컨텍스트를 소모
    - 큰 API 응답이나 긴 파일 내용은 토큰 낭비 가능
    - 필요한 정보만 요청하도록 명확히 지시하는 것이 중요
- 실행 권한과 안전성
    - AI가 실제 시스템 명령어를 실행할 수 있음
    - MCP 서버로 전송되는 데이터 외부 유출 위험
    - 파일 삭제, 데이터베이스 수정 등 위험한 작업 가능
    - 대부분의 도구는 사용자 승인을 요구하는 안전장치 포함 필요
- 비용 증가
    - 도구 호출마다 추가 토큰 소모
    - API 호출 비용(외부 서비스 사용 시)
    - 복잡한 작업일수록 여러 도구를 연쇄 호출하여 비용 상승

## 보안

프로덕션 코드에서 AI 어시스턴트 사용 시 가장 민감하고 중요한 부분으로, 내 코드가 반드시 AI 서버로 전송된다는 점을 이해하는 것이 중요하다.

- 무료/개인용 플랜: 모델 학습에 사용될 가능성이 높음
- 기업용(Enterprise) 유료 플랜: 일반적으로 데이터가 저장되거나 학습에 사용되지 않음(Zero-Retention) 보장 가능

따라서 민감한 코드를 다루기 전, 사용하려는 서비스의 데이터 프라이버시 및 이용 약관을 확인하는 것이 중요하다.
