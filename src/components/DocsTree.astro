---
import { getCollection } from 'astro:content';
import TreeSection from './TreeSection.astro';
import LinkList from './LinkList.astro';

// docsLoader id format: 'docs/subcategory/slug' for docs, 'docs/subcategory' for index pages

// Subcategories that have at least one doc (= migrated)
const allDocs = await getCollection('docs', ({ id }) => {
  const parts = id.split('/');
  return parts[0] === 'docs' && parts.length >= 3;
});

const migratedSubcategories = new Set(
  allDocs.map(doc => doc.id.split('/')[1])
);

// Subcategories that have an index page: id is exactly 'docs/subcategory' (2 parts)
const indexPages = await getCollection('docs', ({ id }) => {
  const parts = id.split('/');
  return parts.length === 2 && parts[0] === 'docs';
});

const subcategoriesWithIndex = new Set(indexPages.map(p => p.id.split('/')[1]));

const groups = [
  { label: 'Computer Science', items: [
    { key: 'computer-architecture', label: 'Computer Architecture' },
    { key: 'operating-system', label: 'Operating System' },
    { key: 'network', label: 'Network' },
    { key: 'secure', label: 'Secure' },
  ]},
  { label: 'Database', items: [
    { key: 'mysql', label: 'MySQL' },
    { key: 'redis', label: 'Redis' },
  ]},
  { label: 'Language', items: [
    { key: 'java', label: 'Java' },
  ]},
  { label: 'Framework', items: [
    { key: 'spring', label: 'Spring' },
  ]},
  { label: 'Messaging & Streaming', items: [
    { key: 'kafka', label: 'Kafka' },
  ]},
  { label: 'Software Engineering', items: [
    { key: 'test', label: 'Test' },
    { key: 'ai-assisted-development', label: 'AI-Assisted Development' },
  ]},
  { label: 'DevOps & Infra', items: [
    { key: 'docker', label: 'Docker' },
  ]},
  { label: 'System Architecture', items: [
    { key: 'large-scale-system', label: 'Large-Scale System' },
  ]},
  { label: 'Design Pattern', items: [
    { key: 'oop', label: 'OOP' },
  ]},
  { label: 'ETC', items: [
    { key: 'setting', label: 'Setting' },
  ]},
];

const visibleGroups = groups.map(group => ({
  ...group,
  items: group.items.filter(item => migratedSubcategories.has(item.key)),
})).filter(group => group.items.length > 0);
---

<div class="docs-tree">
  {visibleGroups.length === 0 ? (
    <p class="empty-state">문서가 없습니다.</p>
  ) : visibleGroups.map(group => (
    <TreeSection label={group.label}>
      <LinkList items={group.items.map(item => ({
        title: item.label,
        url: subcategoriesWithIndex.has(item.key) ? `/docs/${item.key}/` : null,
      }))} />
    </TreeSection>
  ))}
</div>

<style>
  .docs-tree {
    display: flex;
    flex-direction: column;
    gap: 2rem;
    padding: 1rem 0;
  }

  .empty-state {
    color: var(--sl-color-gray-3);
    font-size: 0.9rem;
  }
</style>
